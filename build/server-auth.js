// Generated by CoffeeScript 1.6.1
(function() {
  var ChatClient, ClientHolder, MS, NETCODES, WebSocketServer, ch, fs, handleMessageRequest, logDir, logMessage, logServerInfo, logUserInfo, logWithTime, postPasswd, request, validateAuthReq, wss, wssConfig,
    _this = this;

  WebSocketServer = require("ws").Server;

  fs = require("fs");

  request = require("request");

  NETCODES = require("./netcodes.js").NETCODES;

  MS = require("./message.js").MessageSerializer;

  ClientHolder = (function() {

    function ClientHolder() {
      this.clients = [];
    }

    ClientHolder.prototype.addClient = function(client) {
      if ((client.ws != null) && (client.uID != null) && (client.authorized != null) === true) {
        return this.clients.push(client);
      }
    };

    ClientHolder.prototype.delClientByWS = function(ws) {
      var client, i, _i, _len, _ref, _results;
      _ref = this.clients;
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        client = _ref[i];
        if ((client != null ? client.ws : void 0) === ws) {
          _results.push(this.clients.splice(i, 1));
        }
      }
      return _results;
    };

    ClientHolder.prototype.getClientByuID = function(uID) {
      var client, _i, _len, _ref;
      _ref = this.clients;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        client = _ref[_i];
        if ((client != null ? client.uID : void 0) === uID) {
          return client;
        }
      }
      return null;
    };

    ClientHolder.prototype.getClientByWS = function(ws) {
      var client, _i, _len, _ref;
      _ref = this.clients;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        client = _ref[_i];
        if ((client != null ? client.ws : void 0) === ws) {
          return client;
        }
      }
      return null;
    };

    ClientHolder.prototype.getClientCount = function() {
      return this.clients.length;
    };

    return ClientHolder;

  })();

  ChatClient = (function() {

    function ChatClient(ws, clientHolder) {
      var _this = this;
      this.ws = ws;
      this.clientHolder = clientHolder;
      this.handleRequest = function(reqObject) {
        return ChatClient.prototype.handleRequest.apply(_this, arguments);
      };
      this.uID = void 0;
      this.authenticated = false;
      this.ws.on("message", this.handleRequest);
    }

    ChatClient.prototype.authenticateConnection = function(authObject) {
      if (validateAuthReq(authObject)) {
        return this.checkSession(authObject.SESSID);
      } else {
        this.transmit({
          type: NETCODES.AUTH_RES,
          response: {
            value: false,
            reason: "AUTH_REQ INVALID"
          }
        });
        return false;
      }
    };

    ChatClient.prototype.authenticateUser = function(authObject) {
      if ((authObject != null ? authObject.loggedin : void 0) === !true) {
        this.transmit({
          type: NETCODES.AUTH_RES,
          response: {
            value: false,
            reason: "SESSION INVALID"
          }
        });
        return false;
      }
      if (!(authObject != null ? authObject.uID : void 0)) {
        this.transmit({
          type: NETCODES.AUTH_RES,
          response: {
            value: false,
            reason: "NO LEGAL UID"
          }
        });
        ws.close(4027, "NO LEGAL UID");
        return false;
      }
      if (authObject.loggedin === true) {
        this.authorized = true;
        this.uID = authObject.uID;
        this.clientHolder.addClient(this);
        this.transmit({
          type: NETCODES.AUTH_RES,
          response: {
            value: true,
            uID: authObject.uID
          }
        });
        logUserInfo("" + authObject.uID + " connected.");
        return true;
      }
      return false;
    };

    ChatClient.prototype.checkSession = function(sessid) {
      var checkObject,
        _this = this;
      checkObject = void 0;
      return request.post("http://latest.portaln.se/skola/chatapi.php", {
        form: {
          passwd: postPasswd,
          SESSID: sessid
        }
      }, function(error, response, body) {
        if (response.statusCode === 200 && !error) {
          checkObject = JSON.parse(body);
        }
        return _this.authenticateUser(checkObject);
      });
    };

    ChatClient.prototype.handleRequest = function(reqObject) {
      var parsedReq;
      parsedReq = MS.deserialize(reqObject);
      switch (parsedReq.type) {
        case NETCODES.AUTH_REQ:
          this.authenticateConnection(parsedReq);
          break;
        case NETCODES.MSG_SEND_REQ:
          handleMessageRequest(this, parsedReq.message);
      }
      return void 0;
    };

    ChatClient.prototype.transmit = function(msgObject) {
      try {
        this.ws.send(MS.serialize(msgObject));
        return null;
      } catch (error) {
        return error;
      }
    };

    ChatClient.prototype.transmitMessage = function(msgObject) {
      var error;
      error = this.transmit({
        type: NETCODES.MSG,
        message: msgObject
      });
      if (error != null) {
        return error;
      }
    };

    return ChatClient;

  })();

  validateAuthReq = function(authObject) {
    return (authObject != null ? authObject.type : void 0) === NETCODES.AUTH_REQ && (authObject != null ? authObject.SESSID : void 0);
  };

  handleMessageRequest = function(client, msgObject) {
    var clientFrom, clientTo;
    clientFrom = ch.getClientByWS(client.ws);
    if (clientFrom == null) {
      client.transmit({
        type: NETCODES.MSG_SEND_RES,
        response: {
          id: msgObject.id,
          value: false,
          reason: "not-connected"
        }
      });
    }
    msgObject.fromuID = clientFrom.uID;
    clientTo = ch.getClientByuID(msgObject.touID);
    if (clientTo != null) {
      clientTo.transmitMessage(msgObject);
    }
    client.transmit({
      type: NETCODES.MSG_SEND_RES,
      response: {
        id: msgObject.id,
        value: true
      }
    });
    return logMessage(msgObject);
  };

  logWithTime = function(txt) {
    return "\n[" + (Date.now()) + "] " + txt;
  };

  logUserInfo = function(info) {
    var logString;
    logString = logWithTime("@" + info);
    return fs.appendFile("" + logDir + "activity.log", logString, function(err) {
      if (err) {
        return console.log("Error writing activity.log");
      }
    });
  };

  logServerInfo = function(info) {
    var logString;
    logString = logWithTime("#" + info);
    return fs.appendFile("" + logDir + "server.log", logString, function(err) {
      if (err) {
        return console.log("Error writing server.log");
      }
    });
  };

  logMessage = function(msgObject, callback) {
    return process.nextTick(function() {
      var fileNames, logDir, logString, name, written, _i, _len;
      logDir = "log/";
      logString = "\n[" + msgObject.timeStamp + "] " + msgObject.fromuID + "->" + msgObject.touID + " " + msgObject.content;
      fileNames = ["" + msgObject.fromuID + "-" + msgObject.touID + ".log", "" + msgObject.touID + "-" + msgObject.fromuID + ".log"];
      written = false;
      for (_i = 0, _len = fileNames.length; _i < _len; _i++) {
        name = fileNames[_i];
        if (fs.existsSync("" + logDir + name) && !written) {
          (function() {
            fs.appendFileSync("" + logDir + name, logString);
            return written = true;
          })();
        }
      }
      if (!written) {
        return fs.appendFileSync("" + logDir + fileNames[0], logString);
      }
    });
  };

  wssConfig = {
    port: 1337
  };

  wss = new WebSocketServer(wssConfig);

  ch = new ClientHolder();

  postPasswd = "94bfd1921fe7663e776528e678e56f33";

  logDir = "log/";

  wss.on("connection", function(ws) {
    var client;
    client = new ChatClient(ws, ch);
    return ws.on("close", function(code, reason) {
      if (ch.getClientByWS(ws)) {
        logUserInfo("" + (ch.getClientByWS(ws).uID) + " disconnected.");
        return ch.delClientByWS(ws);
      }
    });
  });

}).call(this);
